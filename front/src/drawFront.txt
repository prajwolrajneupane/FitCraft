import React, { useRef, useEffect, useState } from 'react'
import { Canvas, useLoader, useThree, useFrame } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import { Box3, Vector3, CanvasTexture } from 'three'
import { useParams, useLocation } from "react-router-dom";


function Dress({ color, canvasRef }) {
    const [bgImage, setBgImage] = useState(null);
const { name } = useParams();
  const location = useLocation();
  const items = location.state;


  const gltf = useLoader(GLTFLoader, items.threeD)
  const ref = useRef()
  const { camera } = useThree();
  const textureRef = useRef(null)


  useEffect(() => {
    if (ref.current) {
      const box = new Box3().setFromObject(ref.current)
      const center = new Vector3()
      const size = new Vector3()
      box.getCenter(center)
      box.getSize(size)

      ref.current.position.sub(center)

      const maxDim = Math.max(size.x, size.y, size.z)
      const cameraZ = maxDim * 2
      camera.position.set(0, 0, cameraZ)
      camera.lookAt(0, 0, 0)
    }
  }, [gltf, camera])

  useEffect(() => {
    if (canvasRef.current) {
      textureRef.current = new CanvasTexture(canvasRef.current)
    }
  }, [canvasRef])

  useFrame(() => {
    if (textureRef.current) {
      textureRef.current.needsUpdate = true
    }
  })

useEffect(() => {
  if (ref.current && textureRef.current) {
    ref.current.traverse((child) => {
      if (child.isMesh && child.material) {
        if (Array.isArray(child.material)) {
          child.material.forEach((mat) => {
            if (mat.name === 'Front') {
              mat.map = textureRef.current
              mat.needsUpdate = true
            }
          })
        } else {
          if (child.material.name === 'Front') {
            child.material.map = textureRef.current
       
          }
        }
      }
    })
  }
}, [color])


  useEffect(() => {
  if (ref.current && textureRef.current) {
    ref.current.traverse((child) => {
      if (child.isMesh && child.material) {
        console.log('Mesh:', child.name)
        if (Array.isArray(child.material)) {
          child.material.forEach((mat) => {
            console.log('Material:', mat.name)
          })
        } else {
          console.log('Material:', child.material.name)
        }
      }
    })
  }
}, [])
  return <primitive ref={ref} object={gltf.scene} scale={[0.1, 0.1, 0.1]} />
}

function App() {
  const [color, setColor] = useState('#ffffff')
  const [drawColor, setDrawColor] = useState('#000000')
  const [mode, setMode] = useState('draw')
  const canvasRef = useRef(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [lastPos, setLastPos] = useState({ x: 0, y: 0 })

  // Image states
  const [image, setImage] = useState(null)
  const [imgPos, setImgPos] = useState({ x: 100, y: 100 })
  const [imgSize, setImgSize] = useState({ width: 100, height: 100 })
  const [isDraggingImage, setIsDraggingImage] = useState(false)
  const [isResizingImage, setIsResizingImage] = useState(false)
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  const [resizeStartPos, setResizeStartPos] = useState({ x: 0, y: 0 })
  const [startSize, setStartSize] = useState({ width: 0, height: 0 })

  const handleSize = 15

  // Draw canvas content including image and resize handle
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext('2d')

    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.fillStyle = '#ffffff'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    if (image) {
      ctx.drawImage(image, imgPos.x, imgPos.y, imgSize.width, imgSize.height)

      // Always draw resize handle for user feedback
      ctx.fillStyle = 'blue'
      ctx.fillRect(
        imgPos.x + imgSize.width - handleSize,
        imgPos.y + imgSize.height - handleSize,
        handleSize,
        handleSize
      )
    }
  }, [image, imgPos, imgSize])

  const handleImageUpload = (e) => {
    const file = e.target.files[0]
    if (!file) return

    const img = new Image()
    img.onload = () => setImage(img)
    img.src = URL.createObjectURL(file)
  }

  const isOverResizeHandle = (x, y) => {
    if (!image) return false
    return (
      x >= imgPos.x + imgSize.width - handleSize &&
      x <= imgPos.x + imgSize.width &&
      y >= imgPos.y + imgSize.height - handleSize &&
      y <= imgPos.y + imgSize.height
    )
  }

  const startDrawing = (e) => {
    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    if (mode === 'resize') {
      if (isOverResizeHandle(x, y)) {
        setIsResizingImage(true)
        setResizeStartPos({ x, y })
        setStartSize({ ...imgSize })
        return
      }
    }

    if (mode === 'move') {
      if (
        image &&
        x >= imgPos.x &&
        x <= imgPos.x + imgSize.width &&
        y >= imgPos.y &&
        y <= imgPos.y + imgSize.height
      ) {
        setIsDraggingImage(true)
        setDragOffset({ x: x - imgPos.x, y: y - imgPos.y })
        return
      }
    }

    if (mode === 'draw') {
      setLastPos({ x, y })
      setIsDrawing(true)
    }
  }

  const draw = (e) => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    const rect = canvas.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    if (isResizingImage) {
      const dx = x - resizeStartPos.x
      const dy = y - resizeStartPos.y
      const newWidth = Math.max(20, startSize.width + dx)
      const newHeight = Math.max(20, startSize.height + dy)
      setImgSize({ width: newWidth, height: newHeight })
      return
    }

    if (isDraggingImage) {
      setImgPos({ x: x - dragOffset.x, y: y - dragOffset.y })
      return
    }

    if (isDrawing) {
      ctx.beginPath()
      ctx.moveTo(lastPos.x, lastPos.y)
      ctx.lineTo(x, y)
      ctx.strokeStyle = drawColor
      ctx.lineWidth = 5
      ctx.lineCap = 'round'
      ctx.stroke()
      ctx.closePath()

      setLastPos({ x, y })
    }
  }

  const stopDrawing = () => {
    setIsDrawing(false)
    setIsDraggingImage(false)
    setIsResizingImage(false)
  }

  // Update cursor dynamically on mouse move
  const handleMouseMove = (e) => {
    if (isDraggingImage || isResizingImage || isDrawing) {
      draw(e)
      return
    }

    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    if (mode === 'resize' && isOverResizeHandle(x, y)) {
      canvasRef.current.style.cursor = 'nwse-resize'
    } else if (mode === 'move') {
      if (
        image &&
        x >= imgPos.x &&
        x <= imgPos.x + imgSize.width &&
        y >= imgPos.y &&
        y <= imgPos.y + imgSize.height
      ) {
        canvasRef.current.style.cursor = 'move'
      } else {
        canvasRef.current.style.cursor = 'default'
      }
    } else if (mode === 'draw') {
      canvasRef.current.style.cursor = 'crosshair'
    } else {
      canvasRef.current.style.cursor = 'default'
    }
  }

  // Touch events (similar to mouse events, for brevity just main logic)
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const handleTouchStart = (e) => {
      const touch = e.touches[0]
      const rect = canvas.getBoundingClientRect()
      const x = touch.clientX - rect.left
      const y = touch.clientY - rect.top

      if (mode === 'resize') {
        if (isOverResizeHandle(x, y)) {
          setIsResizingImage(true)
          setResizeStartPos({ x, y })
          setStartSize({ ...imgSize })
          return
        }
      }

      if (mode === 'move') {
        if (
          image &&
          x >= imgPos.x &&
          x <= imgPos.x + imgSize.width &&
          y >= imgPos.y &&
          y <= imgPos.y + imgSize.height
        ) {
          setIsDraggingImage(true)
          setDragOffset({ x: x - imgPos.x, y: y - imgPos.y })
          return
        }
      }

      if (mode === 'draw') {
        setLastPos({ x, y })
        setIsDrawing(true)
      }
    }

    const handleTouchMove = (e) => {
      if (!canvas) return
      const touch = e.touches[0]
      const rect = canvas.getBoundingClientRect()
      const x = touch.clientX - rect.left
      const y = touch.clientY - rect.top

      if (isResizingImage) {
        const dx = x - resizeStartPos.x
        const dy = y - resizeStartPos.y
        const newWidth = Math.max(20, startSize.width + dx)
        const newHeight = Math.max(20, startSize.height + dy)
        setImgSize({ width: newWidth, height: newHeight })
        return
      }

      if (isDraggingImage) {
        setImgPos({ x: x - dragOffset.x, y: y - dragOffset.y })
        return
      }

      if (isDrawing) {
        const ctx = canvas.getContext('2d')
        ctx.beginPath()
        ctx.moveTo(lastPos.x, lastPos.y)
        ctx.lineTo(x, y)
        ctx.strokeStyle = drawColor
        ctx.lineWidth = 5
        ctx.lineCap = 'round'
        ctx.stroke()
        ctx.closePath()

        setLastPos({ x, y })
      }
    }

    const handleTouchEnd = () => {
      setIsDrawing(false)
      setIsDraggingImage(false)
      setIsResizingImage(false)
    }

    canvas.addEventListener('touchstart', handleTouchStart)
    canvas.addEventListener('touchmove', handleTouchMove)
    canvas.addEventListener('touchend', handleTouchEnd)

    return () => {
      canvas.removeEventListener('touchstart', handleTouchStart)
      canvas.removeEventListener('touchmove', handleTouchMove)
      canvas.removeEventListener('touchend', handleTouchEnd)
    }
  }, [
    mode,
    isResizingImage,
    isDraggingImage,
    isDrawing,
    drawColor,
    lastPos,
    imgPos,
    imgSize,
    dragOffset,
    resizeStartPos,
    startSize,
    image,
  ])

  return (
    <>
      <div style={{ position: 'absolute', top: 20, left: 20, zIndex: 1 }}>
        <input
          type="color"
          value={color}
          onChange={(e) => setColor(e.target.value)}
          style={{ marginRight: 10 }}
          title="T-shirt base color"
        />
        <input
          type="color"
          value={drawColor}
          onChange={(e) => setDrawColor(e.target.value)}
          title="Draw color"
        />

        <select
          value={mode}
          onChange={(e) => setMode(e.target.value)}
          style={{ marginLeft: 10 }}
          title="Select mode"
        >
          <option value="draw">Draw</option>
          <option value="move">Move Image</option>
          <option value="resize">Resize Image</option>
        </select>

        <input
          type="file"
          accept="image/*"
          onChange={handleImageUpload}
          style={{ marginLeft: 10 }}
          title="Upload image to add"
        />
      </div>

      <div style={{ display: 'flex', gap: '20px', padding: 20 }}>
        <canvas
          ref={canvasRef}
          width={400}
          height={400}
          onMouseDown={startDrawing}
          onMouseMove={handleMouseMove}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          style={{
            border: '1px solid black',
            touchAction: 'none',
          }}
        />

        <div style={{ width: '100%', height: '500px' }}>
          <Canvas camera={{ position: [0, 0, 2], fov: 45 }}>
            <ambientLight intensity={0.5} />
            <directionalLight position={[2, 5, 1]} intensity={1.2} />
            <Dress color={color} canvasRef={canvasRef} />
            <OrbitControls />
          </Canvas>
        </div>
      </div>
    </>
  )
}

export default App