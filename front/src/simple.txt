import React, { useRef, useEffect, useState } from 'react';
import { Canvas, useLoader, useThree, useFrame } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { Box3, Vector3, CanvasTexture } from 'three';
import { useParams, useLocation } from 'react-router-dom';

// 3D Dress Component
function Dress({ canvasTextures, activeSide }) {
  const { name } = useParams();
  const location = useLocation();
  const items = location.state;
  const gltf = useLoader(GLTFLoader, items.threeD);
  const ref = useRef();
  const { camera } = useThree();

  useEffect(() => {
    if (ref.current) {
      const box = new Box3().setFromObject(ref.current);
      const center = new Vector3();
      const size = new Vector3();
      box.getCenter(center);
      box.getSize(size);
      ref.current.position.sub(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      camera.position.set(0, 0, maxDim * 2);
      camera.lookAt(0, 0, 0);
    }
  }, [gltf, camera]);

  useFrame(() => {
    ['Front', 'Back'].forEach((side) => {
      if (canvasTextures[side]) {
        canvasTextures[side].needsUpdate = true;
      }
    });
  });

  useEffect(() => {
    if (ref.current) {
      ref.current.traverse((child) => {
        if (child.isMesh && child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((mat) => {
              mat.map = null;
              mat.needsUpdate = true;
              if (canvasTextures[mat.name]) {
                mat.map = canvasTextures[mat.name];
                mat.needsUpdate = true;
              }
            });
          } else {
            const mat = child.material;
            mat.map = null;
            mat.needsUpdate = true;
            if (canvasTextures[mat.name]) {
              mat.map = canvasTextures[mat.name];
              mat.needsUpdate = true;
            }
          }
        }
      });
    }
  }, [canvasTextures]);

  return <primitive ref={ref} object={gltf.scene} scale={[0.1, 0.1, 0.1]} />;
}

// Main App
function App() {
  const [drawColor, setDrawColor] = useState('#000000');
  const [activeSide, setActiveSide] = useState('Front');
  const canvasRefs = {
    Front: useRef(document.createElement('canvas')),
    Back: useRef(document.createElement('canvas')),
  };
  const visibleCanvasRef = useRef(null);
  const canvasTextures = {
    Front: useRef(null),
    Back: useRef(null),
  };

  const [isDrawing, setIsDrawing] = useState(false);
  const [lastPos, setLastPos] = useState({ x: 0, y: 0 });

  // Initialize Front and Back canvas
  useEffect(() => {
    ['Front', 'Back'].forEach((side) => {
      const canvas = canvasRefs[side].current;
      canvas.width = 400;
      canvas.height = 400;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      canvasTextures[side].current = new CanvasTexture(canvas);
    });

    // Set initial visible canvas
    if (visibleCanvasRef.current) {
      const ctx = visibleCanvasRef.current.getContext('2d');
      ctx.drawImage(canvasRefs[activeSide].current, 0, 0);
    }
  }, []);

  // Update visible canvas on side change
  useEffect(() => {
    const visibleCanvas = visibleCanvasRef.current;
    if (visibleCanvas) {
      const ctx = visibleCanvas.getContext('2d');
      ctx.clearRect(0, 0, 400, 400);
      ctx.drawImage(canvasRefs[activeSide].current, 0, 0);
    }
  }, [activeSide]);

  const updateMasterCanvas = () => {
    const visibleCanvas = visibleCanvasRef.current;
    const sideCanvas = canvasRefs[activeSide].current;
    const sideCtx = sideCanvas.getContext('2d');
    sideCtx.clearRect(0, 0, 400, 400);
    sideCtx.drawImage(visibleCanvas, 0, 0);
  };

  const startDrawing = (e) => {
    const rect = visibleCanvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    setLastPos({ x, y });
    setIsDrawing(true);
  };

  const draw = (e) => {
    if (!isDrawing) return;
    const rect = visibleCanvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const ctx = visibleCanvasRef.current.getContext('2d');
    ctx.beginPath();
    ctx.moveTo(lastPos.x, lastPos.y);
    ctx.lineTo(x, y);
    ctx.strokeStyle = drawColor;
    ctx.lineWidth = 5;
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.closePath();
    setLastPos({ x, y });

    updateMasterCanvas();
  };

  const stopDrawing = () => {
    setIsDrawing(false);
  };

  return (
    <>
      <div style={{ position: 'absolute', top: 20, left: 20, zIndex: 1, display: 'flex', gap: '10px' }}>
        <input type="color" value={drawColor} onChange={(e) => setDrawColor(e.target.value)} title="Draw color" />
        <button onClick={() => setActiveSide('Front')}>Front</button>
        <button onClick={() => setActiveSide('Back')}>Back</button>
        <div>Active side: <b>{activeSide}</b></div>
      </div>

      <div style={{ display: 'flex', gap: '20px', padding: 20 }}>
        <canvas
          ref={visibleCanvasRef}
          width={400}
          height={400}
          onMouseDown={startDrawing}
          onMouseMove={draw}
          onMouseUp={stopDrawing}
          onMouseLeave={stopDrawing}
          style={{ border: '1px solid black', touchAction: 'none', cursor: 'crosshair' }}
        />

        <div style={{ width: '100%', height: '500px' }}>
          <Canvas camera={{ position: [0, 0, 2], fov: 45 }}>
            <ambientLight intensity={0.5} />
            <directionalLight position={[2, 5, 1]} intensity={1.2} />
            <Dress
              canvasTextures={{
                Front: canvasTextures.Front.current,
                Back: canvasTextures.Back.current,
              }}
              activeSide={activeSide}
            />
            <OrbitControls />
          </Canvas>
        </div>
      </div>
    </>
  );
}

export default App;
